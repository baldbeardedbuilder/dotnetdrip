---
description: Optimize a project spec for sub-agent implementation using progressive disclosure and Anthropic's long-running agent techniques
argument-hint: "<plan-file-path>"
---

# Optimize Project Spec for Sub-Agent Implementation

Transform a project specification into an optimized implementation plan designed for Claude Code sub-agents.

## Input

- **Plan file**: $ARGUMENTS - Path to the plan markdown file (e.g., `dev/active/my-feature/plan.md`)
- **Output dir**: Derived from plan file's parent directory (e.g., `dev/active/my-feature/`)

## Tools

These tools enhance the optimization process but are not required. The command works without them.

- **Sequential Thinking** (optional): If the `sequentialthinking` MCP tool is available, use it for:
  - Decomposing the plan into discrete features
  - Analyzing dependencies between features
  - Deciding on layer groupings
  - Mapping edge cases and decisions to features
  - Resolving ambiguity in feature boundaries

- **Context7** (optional): If `resolve-library-id` and `get-library-docs` MCP tools are available, use them to:
  - Fetch current documentation for libraries mentioned in the plan
  - Include relevant API details in feature prompts
  - First resolve the library ID, then fetch docs for specific topics

- **Filesystem** (optional): If filesystem MCP tools are available (`read_file`, `write_file`, `create_directory`, `directory_tree`, `search_files`), use them to:
  - Read the input plan file
  - Write all output files
  - Create the prompts directory
  - Explore project structure for additional context

- **Documentation** (optional): If the `documentation` MCP tool is available, use it to:
  - Search Microsoft/Azure docs for relevant guidance
  - Include official best practices in constraints

- **Beads** (optional): If `.beads/` directory exists, use bd CLI for issue tracking.
  See `.claude/skills/beads-cli/SKILL.md` for commands and best practices.

## Techniques to Apply

### From Anthropic's Long-Running Agent Blog

Reference: https://www.anthropic.com/engineering/effective-harnesses-for-long-running-agents

1. **Feature-List Scaffolding**: Create `manifest.jsonl` with testable features, each with:

   - Unique ID and clear description
   - Concrete acceptance criteria
   - Status tracking: `pending` | `in_progress` | `completed` | `failed`
   - Verification command
   - Edge case and decision references

2. **One-Feature-Per-Session**: Each prompt tackles exactly ONE feature with explicit constraint:

   > "It is unacceptable to implement features beyond the scope of this task."

3. **Git-Based State Management**: Every prompt ends with commit instructions

4. **Testing-First Validation**: Verification commands in each prompt

### From Progressive Disclosure UX

Reference: https://www.nngroup.com/articles/progressive-disclosure/

1. **Ordered Complexity**: Structure from simple foundation → complex features
2. **Reduce Cognitive Load**: Small, focused prompts instead of monolithic spec
3. **Context Preservation**: Each prompt references prior completed work and relevant decisions
4. **Layered Information**: Group features into dependency layers

## Output Structure

Create this structure in the output directory:

```
<output-directory>/
├── README.md              # Orchestration guide
├── manifest.jsonl         # Feature metadata for orchestration
├── context.md             # Summary, rationale, architecture vision
├── decisions.md           # Decision log with rationale
├── edge-cases.md          # Global edge cases reference
├── testing-strategy.md    # Holistic testing approach
├── constraints.md         # Global rules for all agents
├── init.md                # Initializer agent prompt
├── code/                  # Code samples by language
│   ├── typescript.md      # TypeScript patterns and examples
│   ├── css.md             # CSS/styling patterns
│   ├── html.md            # HTML templates
│   ├── bash.md            # Shell commands and scripts
│   └── ...                # Other languages as needed
└── prompts/
    ├── 01-<feature>.md
    ├── 02-<feature>.md
    └── ...
```

## Workflow

### Step 0: Research Phase (Parallel Async Agents)

Before optimizing the plan, spawn 4 research agents in parallel to build reusable knowledge:

1. **Check for existing research docs** in `docs/research/planning/`:
   - `planning-workflow-analysis.md`
   - `beads-integration-patterns.md`
   - `existing-plans-analysis.md`
   - `state-management-strategies.md`

2. **Spawn 4 research agents in parallel** using the Task tool:

   **Agent 1: Planning Workflow Analysis** (Explore agent)
   - Description: "Analyze planning workflow"
   - Prompt:
     ```
     Analyze current planning workflow:
     - Read .claude/commands/plan-new.md
     - Read .claude/commands/plan-optimize.md
     - Read .claude/commands/plan-orchestrate.md
     - Document findings in docs/research/planning/planning-workflow-analysis.md

     If the file already exists, read it first and update/append rather than overwrite.
     Focus on: command structure, workflow phases, file outputs, integration points.
     ```
   - Run in background: true

   **Agent 2: Beads Integration Patterns** (Explore agent)
   - Description: "Extract beads patterns"
   - Prompt:
     ```
     Extract beads CLI patterns:
     - Read .claude/skills/beads-cli/SKILL.md
     - Document epic/task/dependency patterns
     - Write to docs/research/planning/beads-integration-patterns.md

     If the file already exists, read it first and update/append rather than overwrite.
     Focus on: epic creation, task creation with --parent, dependency management, status tracking.
     ```
   - Run in background: true

   **Agent 3: Existing Plans Analysis** (Explore agent)
   - Description: "Analyze existing plans"
   - Prompt:
     ```
     Analyze existing plan structures:
     - Find all manifest.jsonl files in dev/active/*/
     - Document common patterns in manifest structure
     - Write to docs/research/planning/existing-plans-analysis.md

     If the file already exists, read it first and update/append rather than overwrite.
     Focus on: feature structure, dependency patterns, verification commands, status tracking.
     ```
   - Run in background: true

   **Agent 4: State Management Strategies** (general-purpose agent)
   - Description: "Research state management"
   - Prompt:
     ```
     Research idempotent orchestration patterns:
     - Web search: "idempotent workflow orchestration"
     - Web search: "crash recovery state management"
     - Analyze findings for applicable patterns
     - Write to docs/research/planning/state-management-strategies.md

     If the file already exists, read it first and update/append rather than overwrite.
     Focus on: crash recovery, idempotency, state reconciliation, retry strategies.
     ```
   - Run in background: true

3. **Wait for all agents to complete** before proceeding to optimization

4. **Review research outputs** to inform feature breakdown and constraints

### Step 1: Create Beads Epic (Optional)

If beads is initialized (`.beads/` directory exists), create an epic for this plan:

1. **Check beads availability**: Test if `.beads/` directory exists
2. **Extract plan metadata**:
   - Read the input plan file to extract the title (first H1 heading)
   - Extract the summary (content under the "## Summary" section)
3. **Create epic**:
   ```bash
   # Only if .beads/ exists
   if [ -d .beads ]; then
     EPIC_ID=$(bd create --type=epic \
       --title="[Plan Title from H1]" \
       --description="[Summary content]" \
       --silent)

     # Store epic ID for later steps
     echo "$EPIC_ID" > <output-directory>/.beads
   else
     echo "Beads not initialized, skipping epic creation"
   fi
   ```
4. **Store epic ID**: Write the epic ID to `<output-directory>/.beads` for use in later steps (task creation, orchestration)

**Important**: This step is optional. If beads is not initialized, log a message and continue with optimization. The workflow must degrade gracefully without beads.

### Step 1a: Update DevOps Story (Optional)

After epic creation, if DevOps is configured, update the Azure DevOps Story with plan title and description:

1. **Check DevOps availability**: Test if `<output-directory>/.devops` file exists
2. **Load DevOps configuration**:
   ```bash
   # Only if .devops file exists
   if [ -f <output-directory>/.devops ]; then
     source <output-directory>/.devops  # Sets STORY_ID, ORG, PROJECT
   fi
   ```
3. **Update Story**:
   ```bash
   # Update Story title and description from plan
   if [ -f <output-directory>/.devops ] && [ -n "$AZURE_DEVOPS_EXT_PAT" ]; then
     source <output-directory>/.devops

     az boards work-item update $STORY_ID \
       --title "[Plan Title from H1]" \
       --description "[Summary content]" \
       --org $ORG --project $PROJECT 2>&1

     if [ $? -eq 0 ]; then
       echo "DevOps Story $STORY_ID updated successfully"
     else
       echo "WARNING: DevOps Story update failed, continuing without sync"
     fi
   elif [ -f <output-directory>/.devops ]; then
     echo "WARNING: AZURE_DEVOPS_EXT_PAT not set, skipping DevOps sync"
   else
     echo "DevOps not configured, skipping Story update"
   fi
   ```

**Edge cases handled**:
- **EC019**: Invalid Story ID - error message displayed, workflow continues
- **EC020**: Authentication failure - warning logged, workflow continues without DevOps sync

**Important**: This step is optional and provides organizational visibility for teams using Azure DevOps. The workflow continues even if DevOps sync fails.

### Step 1b: Create Beads Tasks (Optional)

After epic creation (Step 1), create beads tasks for each feature in the manifest:

1. **Check beads availability**: Test if `.beads/` directory exists and epic was created
2. **Load epic ID**:
   ```bash
   # Only if .beads/ exists and epic created
   if [ -d .beads ] && [ -f <output-directory>/.beads ]; then
     EPIC_ID=$(cat <output-directory>/.beads)
   fi
   ```
3. **Create tasks from manifest**:
   ```bash
   # For each feature in manifest.jsonl (after it's generated)
   # This happens after Step 13 when manifest.jsonl is created
   if [ -d .beads ] && [ -f <output-directory>/.beads ]; then
     EPIC_ID=$(cat <output-directory>/.beads)

     # Read manifest and create tasks
     while IFS= read -r line; do
       FEATURE_ID=$(echo "$line" | jq -r '.id')
       DESCRIPTION=$(echo "$line" | jq -r '.description')
       PRIORITY=$(echo "$line" | jq -r '.priority // 2')  # Default to P2

       # Create task with parent relationship
       TASK_ID=$(bd create "$DESCRIPTION" \
         --type=task \
         --parent=$EPIC_ID \
         --priority=$PRIORITY \
         --silent)

       # Update manifest with beads_id
       # Store temporarily, will update manifest file after loop
       echo "$FEATURE_ID:$TASK_ID" >> /tmp/task_ids.txt
     done < <output-directory>/manifest.jsonl

     # Update manifest.jsonl with beads_id values
     while IFS=: read -r feature_id task_id; do
       # Update beads_id field in manifest
       jq --arg fid "$feature_id" --arg tid "$task_id" \
         'if .id == $fid then .beads_id = $tid else . end' \
         <output-directory>/manifest.jsonl > <output-directory>/manifest.tmp
       mv <output-directory>/manifest.tmp <output-directory>/manifest.jsonl
     done < /tmp/task_ids.txt

     # Clean up temp file
     rm -f /tmp/task_ids.txt

     echo "Created beads tasks for all features with parent=$EPIC_ID"
   else
     echo "Beads not initialized or epic not created, skipping task creation"
   fi
   ```

**Edge cases handled**:
- **EC001**: Beads not initialized - check for `.beads/` directory, skip if missing
- **EC003**: Orphaned tasks if epic deleted - documented in README, users should close epic properly

**Important**: This step runs AFTER Step 13 (manifest.jsonl creation) but before finishing optimization. Tasks are created with `--parent` relationship to the epic, enabling auto-close via `bd epic close-eligible`.

**Note**: Task creation uses the manifest's priority field (defaults to 2 if not specified). Task IDs are stored in the `beads_id` field of manifest.jsonl for cross-referencing during orchestration.

### Step 1c: Create DevOps Tasks (Optional)

After beads task creation (Step 1b), if DevOps is configured, create DevOps tasks for each feature:

1. **Check DevOps availability**: Test if `<output-directory>/.devops` file exists
2. **Load DevOps configuration**:
   ```bash
   # Only if .devops file exists
   if [ -f <output-directory>/.devops ]; then
     source <output-directory>/.devops  # Sets STORY_ID, ORG, PROJECT
   fi
   ```
3. **Create DevOps tasks from manifest**:
   ```bash
   # For each feature in manifest.jsonl (after it's generated)
   # This happens after Step 13 when manifest.jsonl is created
   if [ -f <output-directory>/.devops ] && [ -n "$AZURE_DEVOPS_EXT_PAT" ]; then
     source <output-directory>/.devops

     # Read manifest and create DevOps tasks
     while IFS= read -r line; do
       FEATURE_ID=$(echo "$line" | jq -r '.id')
       DESCRIPTION=$(echo "$line" | jq -r '.description')

       # Create task as child of Story
       DEVOPS_TASK_ID=$(az boards work-item create \
         --type Task \
         --title "$FEATURE_ID: $DESCRIPTION" \
         --description "Feature: $FEATURE_ID" \
         --parent $STORY_ID \
         --org $ORG --project $PROJECT \
         --output tsv --query id 2>&1)

       if [ $? -eq 0 ]; then
         # Update manifest with devops_id
         # Store temporarily, will update manifest file after loop
         echo "$FEATURE_ID:$DEVOPS_TASK_ID" >> /tmp/devops_task_ids.txt
       else
         echo "WARNING: Failed to create DevOps task for $FEATURE_ID: $DEVOPS_TASK_ID"
         echo "Continuing without DevOps sync for this task"
       fi
     done < <output-directory>/manifest.jsonl

     # Update manifest.jsonl with devops_id values
     if [ -f /tmp/devops_task_ids.txt ]; then
       while IFS=: read -r feature_id task_id; do
         # Update devops_id field in manifest
         jq --arg fid "$feature_id" --arg tid "$task_id" \
           'if .id == $fid then .devops_id = $tid else . end' \
           <output-directory>/manifest.jsonl > <output-directory>/manifest.tmp
         mv <output-directory>/manifest.tmp <output-directory>/manifest.jsonl
       done < /tmp/devops_task_ids.txt

       # Clean up temp file
       rm -f /tmp/devops_task_ids.txt
     fi

     echo "Created DevOps tasks for all features with parent=$STORY_ID"
   elif [ -f <output-directory>/.devops ]; then
     echo "WARNING: AZURE_DEVOPS_EXT_PAT not set, skipping DevOps task creation"
   else
     echo "DevOps not configured, skipping task creation"
   fi
   ```

**Edge cases handled**:
- **EC020**: Authentication failure - warning logged, workflow continues without DevOps sync
- **EC024**: DevOps org/project changed - user must update .devops file manually

**Important**: This step is optional and provides organizational visibility for teams using Azure DevOps. The workflow continues even if DevOps task creation fails. Task IDs are stored in the `devops_id` field of manifest.jsonl for status syncing during orchestration.

### Step 1d: Map Dependencies (Optional)

After task creation (Steps 1b and 1c), map `depends_on` relationships from manifest to beads dependencies and DevOps predecessor links:

1. **Check availability**: Only run if beads initialized or DevOps configured
2. **Map beads dependencies** (if `.beads/` exists):
   ```bash
   # For each feature in manifest.jsonl
   # This happens after Step 1b when beads tasks are created
   if [ -d .beads ]; then
     while IFS= read -r line; do
       FEATURE_ID=$(echo "$line" | jq -r '.id')
       BEADS_ID=$(echo "$line" | jq -r '.beads_id')
       DEPENDS_ON=$(echo "$line" | jq -r '.depends_on[]?')

       # For each dependency
       for dep_feature_id in $DEPENDS_ON; do
         # Look up dependency's beads_id from manifest
         DEP_BEADS_ID=$(jq -r --arg fid "$dep_feature_id" \
           'select(.id == $fid) | .beads_id' \
           <output-directory>/manifest.jsonl)

         # Add dependency (beads detects circular deps)
         if [ -n "$DEP_BEADS_ID" ] && [ "$DEP_BEADS_ID" != "null" ]; then
           bd dep add $BEADS_ID $DEP_BEADS_ID 2>&1 || \
             echo "ERROR: Failed to add dependency $FEATURE_ID → $dep_feature_id: circular dependency or invalid ID"
         fi
       done
     done < <output-directory>/manifest.jsonl

     echo "Mapped beads dependencies from manifest"
   else
     echo "Beads not initialized, skipping dependency mapping"
   fi
   ```

3. **Map DevOps predecessor links** (if `.devops` exists):
   ```bash
   # For each feature in manifest.jsonl
   # This happens after Step 1c when DevOps tasks are created
   if [ -f <output-directory>/.devops ] && [ -n "$AZURE_DEVOPS_EXT_PAT" ]; then
     source <output-directory>/.devops

     while IFS= read -r line; do
       FEATURE_ID=$(echo "$line" | jq -r '.id')
       DEVOPS_ID=$(echo "$line" | jq -r '.devops_id')
       DEPENDS_ON=$(echo "$line" | jq -r '.depends_on[]?')

       # For each dependency
       for dep_feature_id in $DEPENDS_ON; do
         # Look up dependency's devops_id from manifest
         DEP_DEVOPS_ID=$(jq -r --arg fid "$dep_feature_id" \
           'select(.id == $fid) | .devops_id' \
           <output-directory>/manifest.jsonl)

         # Add predecessor relationship (F002 depends on F001 → F001 is predecessor of F002)
         if [ -n "$DEP_DEVOPS_ID" ] && [ "$DEP_DEVOPS_ID" != "null" ] && [ "$DEP_DEVOPS_ID" != "" ]; then
           az boards work-item relation add \
             --id $DEVOPS_ID \
             --relation-type Predecessor \
             --target-id $DEP_DEVOPS_ID \
             --org $ORG --project $PROJECT 2>&1 || \
             echo "WARNING: Failed to add predecessor link $FEATURE_ID → $dep_feature_id"
         fi
       done
     done < <output-directory>/manifest.jsonl

     echo "Mapped DevOps predecessor links from manifest"
   elif [ -f <output-directory>/.devops ]; then
     echo "WARNING: AZURE_DEVOPS_EXT_PAT not set, skipping DevOps dependency mapping"
   else
     echo "DevOps not configured, skipping dependency mapping"
   fi
   ```

**Edge cases handled**:
- **EC005**: Circular dependencies - beads `bd dep add` detects and rejects, error message logged
- Graceful skip if beads not initialized or DevOps not configured
- Handle missing or null ID values safely

**Important**: This step is optional and runs after task creation. It enables proper task ordering in beads (blocked/blocking visibility) and DevOps (predecessor links). The workflow continues even if dependency mapping fails.

### Step 2-16: Plan Optimization

1. **Read** the input spec file
2. **Extract Summary** → Write to `context.md` with the "why" and architecture vision
3. **Extract Decisions** → Write to `decisions.md` preserving rationale with IDs (D001, D002, ...)
4. **Extract Edge Cases** → Write to `edge-cases.md` with IDs (EC001, EC002, ...), note which features each applies to
5. **Extract Testing Strategy** → Write to `testing-strategy.md`
6. **Extract Code Samples** → Organize into `code/` directory by language with progressive disclosure structure
7. **Analyze** to identify discrete features, assign IDs (F001, F002, ...)
8. **Map relationships** - Link edge cases, decisions, and code references to relevant features
9. **Group** features into dependency layers
10. **Write** `constraints.md` referencing context docs and code directory
11. **Write** `init.md` for project setup (F000)
12. **Write** individual prompt files in `prompts/` with code references
13. **Write** `manifest.jsonl` with metadata for each feature
14. **Write** `README.md` with orchestration guide
15. **Create Beads Tasks** (implemented in Step 1b):
    - Tasks created with parent=epic relationship
    - Task IDs stored in manifest.jsonl `beads_id` field
    - See Step 1b above for implementation details
16. **Create DevOps Tasks** (implemented in Step 1c):
    - Tasks created with parent=Story relationship
    - Task IDs stored in manifest.jsonl `devops_id` field
    - See Step 1c above for implementation details
17. **Map Dependencies** (implemented in Step 1d):
    - Map `depends_on` relationships to beads dependencies
    - Map `depends_on` relationships to DevOps predecessor links
    - See Step 1d above for implementation details

## File Formats

### manifest.jsonl

One JSON object per line for streaming/orchestration:

```jsonl
{"id":"F000","file":"init.md","description":"Project initialization","depends_on":[],"edge_cases":[],"decisions":[],"code_refs":[],"status":"pending","verification":"bun run tsc --noEmit","beads_id":""}
{"id":"F001","file":"prompts/01-types.md","description":"Core type definitions","depends_on":["F000"],"edge_cases":[],"decisions":["D001"],"code_refs":["code/typescript.md#basic-types"],"status":"pending","verification":"bun run tsc --noEmit","beads_id":""}
{"id":"F002","file":"prompts/02-auth.md","description":"User authentication","depends_on":["F001"],"edge_cases":["EC001","EC002"],"decisions":["D002"],"code_refs":["code/typescript.md#core-logic","code/typescript.md#hooks"],"status":"pending","verification":"bun test --grep auth","beads_id":""}
```

**Note**: The `beads_id` field is populated during Step 1b if beads is available. This enables cross-referencing between manifest features and beads issues.

### context.md

```markdown
# Project Context

## Summary

[What the feature does and WHY - preserve the rationale from the plan]

## Architecture Vision

[Implementation approach narrative - the cohesive vision for how components fit together]

## Goals

- [High-level goal 1]
- [High-level goal 2]
```

### decisions.md

```markdown
# Architectural Decisions

| ID | Decision | Rationale | Affected Features |
|----|----------|-----------|-------------------|
| D001 | [Choice made] | [Why this was chosen] | F001, F003 |
| D002 | [Choice made] | [Why this was chosen] | F002 |
```

### edge-cases.md

```markdown
# Edge Cases

| ID | Case | Handling | Affected Features |
|----|------|----------|-------------------|
| EC001 | [Edge case description] | [How it's handled] | F002, F005 |
| EC002 | [Edge case description] | [How it's handled] | F002 |
```

### testing-strategy.md

```markdown
# Testing Strategy

## Philosophy

[Overall testing approach from the plan]

## Test Types

- **Unit Tests**: [approach]
- **Integration Tests**: [approach]
- **E2E Tests**: [approach with Playwright]

## Patterns

[Testing patterns discovered from the project]
```

### code/{language}.md

Hierarchical markdown files organized for progressive disclosure. Each file:
- Groups code by concept/topic using headings
- Orders from simple → complex (foundational patterns first)
- Uses anchor-friendly heading IDs for direct linking
- Includes brief context before each code block

Structure each language file like this:

```markdown
# TypeScript Patterns

## Types

### Basic Types
[Foundation types that other code depends on]

```typescript
// Simple, foundational type
interface User {
  id: string;
  name: string;
}
```

### Extended Types
[More complex types building on basics]

```typescript
// Builds on User type
interface UserWithAuth extends User {
  token: string;
  permissions: Permission[];
}
```

## Functions

### Utilities
[Helper functions with no dependencies]

```typescript
export function formatDate(date: Date): string {
  return date.toISOString().split('T')[0];
}
```

### Core Logic
[Main business logic functions]

```typescript
export async function authenticateUser(
  credentials: Credentials
): Promise<UserWithAuth> {
  // Implementation
}
```

## Components

### Base Components
[Foundational UI components]

### Feature Components
[Components that compose base components]

## Hooks

### State Hooks
[Simple state management]

### Effect Hooks
[Side effects and data fetching]
```

**Referencing code in prompts:**

Use relative paths with anchors:
- `code/typescript.md#basic-types` - Link to Types > Basic Types section
- `code/typescript.md#utilities` - Link to Functions > Utilities section
- `code/css.md#layout` - Link to CSS layout patterns

**Progressive disclosure principles for code files:**

1. **Layer 1 - Foundation**: Types, interfaces, constants (no imports from project)
2. **Layer 2 - Utilities**: Pure functions, helpers (import only from Layer 1)
3. **Layer 3 - Core Logic**: Business logic (import from Layers 1-2)
4. **Layer 4 - Components/UI**: UI elements (import from Layers 1-3)
5. **Layer 5 - Integration**: Composition, wiring (import from all layers)

### constraints.md

```markdown
# Global Constraints

## Project Context

See `context.md` for the feature summary and architectural vision.

## Architectural Decisions

See `decisions.md` before making implementation choices. Reference decision IDs in commit messages when relevant.

## Edge Cases

See `edge-cases.md` for cases that may span multiple features. Each prompt lists its relevant edge cases.

## Code Patterns

See `code/` directory for reusable code samples organized by language. Each prompt references specific sections:
- Read the referenced code sections before implementing
- Follow the established patterns for consistency
- Code is organized by progressive disclosure (simple → complex)

## Testing Philosophy

See `testing-strategy.md` for the holistic testing approach.

## MCP Tools (if available)

These tools may be available to assist implementation. Check availability before use.

- **Playwright MCP** (optional): `browser_navigate`, `browser_snapshot`, `browser_click`, `browser_type`, `browser_take_screenshot`, `browser_console_messages` for E2E testing. Use `host.docker.internal` instead of `localhost` for local servers.
- **Context7 MCP** (optional): `resolve-library-id`, `get-library-docs` for fetching up-to-date library documentation.
- **Documentation MCP** (optional): Search Microsoft/Azure docs for official guidance.

## Rules

- One feature per session - do not implement beyond scope
- Commit after each feature
- Run verification before marking complete
- Reference decision IDs when implementing related code
- Follow code patterns from the `code/` directory
```

## Prompt Template

Each prompt file should follow:

````markdown
# Feature: [ID] - [Title]

## Project Context

See `context.md` for feature rationale and architecture vision.

## Prior Work

[What was completed in prior steps - reference feature IDs]

## Objective

[Single, clear goal - ONE feature only]

> **Scope Constraint**: It is unacceptable to implement features beyond this task's scope.

## Relevant Decisions

From `decisions.md`:
- **[ID]**: [Decision summary] — [Why it matters for this feature]

## Edge Cases to Handle

From `edge-cases.md`:
- **[ID]**: [Case] → [Handling]

## Code References

Read these sections before implementing:
- `code/[language].md#[section]` - [What pattern to follow]
- `code/[language].md#[section]` - [What pattern to follow]

## Constraints

- See `constraints.md` for global rules
- [Feature-specific constraints]

## Files to Create/Modify

| File | Purpose |
|------|---------|
| `path/to/file.ts` | [What changes and why] |

## Implementation Details

[Specific code patterns, interfaces to use, implementation guidance]

## Acceptance Criteria

- [ ] [Testable requirement 1]
- [ ] [Testable requirement 2]
- [ ] Edge case [ID] handled correctly

## Verification

Reference `testing-strategy.md` for approach.

```bash
[Command to verify success]
```

## Commit

```bash
git add [files]
git commit -m "feat([scope]): [description]

Implements: [ID]
Decisions: [relevant decision IDs]"
```

## Next

Proceed to: `[next prompt file]` ([next feature ID])
````

## Example Layering

- **Layer 1**: Types, configuration (no dependencies)
- **Layer 2**: Core infrastructure (depends on Layer 1)
- **Layer 3**: Main features (depends on Layer 2)
- **Layer 4**: UI/Styling (may be parallel)
- **Layer 5**: Integration (depends on features)
- **Layer 6**: Testing (depends on implementation)
- **Layer 7**: Final validation (E2E with Playwright)

## README.md Template

```markdown
# [Feature Name] - Implementation Plan

## Overview

[Brief description from context.md]

## Quick Start

1. Run features in order using manifest.jsonl
2. Each prompt is self-contained with context
3. Verify after each feature before proceeding

## Files

| File | Purpose |
|------|---------|
| `manifest.jsonl` | Feature metadata for orchestration |
| `context.md` | Project rationale and architecture |
| `decisions.md` | Architectural decisions with rationale |
| `edge-cases.md` | Edge cases mapped to features |
| `testing-strategy.md` | Testing philosophy and patterns |
| `constraints.md` | Global rules for all prompts |
| `code/*.md` | Code samples by language (progressive disclosure) |
| `init.md` | Project initialization (F000) |
| `prompts/*.md` | Individual feature prompts |

## Code Samples

The `code/` directory contains reusable code patterns organized by language:
- Each file uses hierarchical headings for progressive disclosure
- Reference specific sections via anchors: `code/typescript.md#basic-types`
- Patterns are ordered from simple → complex within each file

## Orchestration

Process manifest.jsonl line by line:

```bash
# Example: Read manifest and execute prompts
while read -r line; do
  file=$(echo "$line" | jq -r '.file')
  # Execute prompt file with sub-agent
done < manifest.jsonl
```

## Feature Status

Track progress by updating status in manifest.jsonl:
- `pending` - Not started
- `in_progress` - Currently being implemented
- `completed` - Done and verified
- `failed` - Needs attention

## Beads Integration (if available)

If `.beads/` exists, issues track features. The `beads_id` field in manifest.jsonl cross-references.
See `.claude/skills/beads-cli/SKILL.md` for commands.

## Decision Log

See `decisions.md` for architectural choices and rationale.
```

Now read the spec file and create the optimized plan.
