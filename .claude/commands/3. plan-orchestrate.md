---
description: Execute an optimized plan by running each feature prompt sequentially with sub-agents
argument-hint: "<plan-directory>"
---

# Orchestrate Plan Execution

Execute an optimized implementation plan by spawning sub-agents for each feature in sequence.

## Input

- **Plan directory**: $ARGUMENTS - Path to directory containing the optimized plan (e.g., `dev/active/ui-updates`)

## Beads Issue Hierarchy

When beads is available, orchestration creates a hierarchical issue structure:

```
Epic: User Authentication Plan
  ↳ Task F001: Implement login
      ↳ Bug: Fix login test coverage (if quality review finds issues)
  ↳ Task F002: Implement logout
      ↳ Bug: Fix logout error handling (if quality review finds issues)
  ↳ Task F003: Add password reset
```

**Key points:**
- **Epic** = Overall plan (created by `/plan-optimize`)
- **Tasks** = Individual features (F001, F002, F003) - children of epic
- **Bugs** = Quality review findings - **children of the feature task that created them**

This hierarchy allows you to:
- View all bugfixes for a specific feature: `bd list --parent=<task_id>`
- See feature progress including bugfixes in perles with tree mode
- Close a feature task and its bugfixes together

## Execution Flow

### 1. Create Feature Branch

Before any implementation work, create a dedicated branch for the plan:

1. **Extract plan name** from the directory path (e.g., `ui-updates` from `dev/active/ui-updates`)
2. **Create branch** named `plan/<plan-name>` (e.g., `plan/ui-updates`)
3. **Switch to the branch** to isolate all plan work

```bash
git checkout -b plan/<plan-name>
```

If the branch already exists (resuming an interrupted plan), switch to it instead:

```bash
git checkout plan/<plan-name>
```

### 2. State Reconciliation

**CRITICAL: This must run before any feature processing.**

State reconciliation syncs manifest.jsonl and beads status to enable crash recovery, handle `/clear` sessions, and make orchestration idempotent.

1. **Sync with remote**: Run `bd sync` to get latest beads state from remote
2. **For each feature in manifest**:
   - Get manifest status and beads_id
   - Skip if no beads_id (beads not initialized)
   - Get beads status using `bd show $BEADS_ID --format=json`
   - Reconcile state differences:
     - **Beads closed + manifest pending**: Update manifest to `completed`
     - **Manifest completed + beads open**: Close beads with reason
     - **Beads in_progress + manifest pending**: Reset beads to `open` (crash recovery)
     - **Beads open + manifest in_progress**: Reset manifest to `pending` (crash recovery)
3. **Log all reconciliation actions** for debugging
4. **Continue with orchestration**

State reconciliation pattern:

```bash
# Sync with remote to get latest beads state
if [ -d .beads ]; then
  echo "=== State Reconciliation ==="
  bd sync

  # For each feature in manifest.jsonl
  for feature in $(jq -c '.' $PLAN_DIR/manifest.jsonl); do
    FEATURE_ID=$(echo "$feature" | jq -r '.id')
    MANIFEST_STATUS=$(echo "$feature" | jq -r '.status')
    BEADS_ID=$(echo "$feature" | jq -r '.beads_id // empty')

    # Skip if no beads_id (beads not initialized for this feature)
    if [ -z "$BEADS_ID" ]; then
      continue
    fi

    # Get beads status
    BEADS_STATUS=$(bd show $BEADS_ID --format=json 2>/dev/null | jq -r '.status // "unknown"')

    # Skip if beads issue not found
    if [ "$BEADS_STATUS" = "unknown" ]; then
      echo "WARNING: Beads issue $BEADS_ID not found for $FEATURE_ID"
      continue
    fi

    # Reconcile state differences (beads is authoritative)
    if [ "$BEADS_STATUS" = "closed" ] && [ "$MANIFEST_STATUS" != "completed" ]; then
      echo "Reconcile: $FEATURE_ID - Beads closed, updating manifest to completed"
      jq "(.[] | select(.id == \"$FEATURE_ID\") | .status) = \"completed\"" \
        $PLAN_DIR/manifest.jsonl > $PLAN_DIR/manifest.jsonl.tmp && \
        mv $PLAN_DIR/manifest.jsonl.tmp $PLAN_DIR/manifest.jsonl
    elif [ "$MANIFEST_STATUS" = "completed" ] && [ "$BEADS_STATUS" != "closed" ]; then
      echo "Reconcile: $FEATURE_ID - Manifest completed, closing beads"
      bd close $BEADS_ID --reason="Reconciliation: manifest shows completed"
    elif [ "$BEADS_STATUS" = "in_progress" ] && [ "$MANIFEST_STATUS" = "pending" ]; then
      echo "Reconcile: $FEATURE_ID - Crash recovery: resetting beads to open"
      bd update $BEADS_ID --status=open
    elif [ "$MANIFEST_STATUS" = "in_progress" ] && [ "$BEADS_STATUS" = "open" ]; then
      echo "Reconcile: $FEATURE_ID - Crash recovery: resetting manifest to pending"
      jq "(.[] | select(.id == \"$FEATURE_ID\") | .status) = \"pending\"" \
        $PLAN_DIR/manifest.jsonl > $PLAN_DIR/manifest.jsonl.tmp && \
        mv $PLAN_DIR/manifest.jsonl.tmp $PLAN_DIR/manifest.jsonl
    fi
  done

  echo "=== State Reconciliation Complete ==="
fi
```

### 3. Load Plan State

Read `manifest.jsonl` from the plan directory. Each line is a JSON object:

```jsonl
{"id":"F000","file":"init.md","description":"...","depends_on":[],"edge_cases":[],"decisions":[],"code_refs":[],"status":"pending","verification":"..."}
{"id":"F001","file":"prompts/01-types.md","description":"...","depends_on":["F000"],"edge_cases":[],"decisions":["D001"],"code_refs":["code/typescript.md#basic-types"],"status":"pending","verification":"..."}
```

Parse to understand:

- Total features and their IDs
- Current status of each feature
- Dependencies between features
- Related edge cases and decisions
- Code references for each feature (`code_refs` array)

### Manifest Fields Used

| Field | Usage |
|-------|-------|
| `id` | Feature identification and dependency resolution |
| `file` | Prompt file to read |
| `description` | Progress reporting |
| `depends_on` | Dependency checking before execution |
| `edge_cases` | Include in sub-agent context with descriptions |
| `decisions` | Include in sub-agent context, verify in commits |
| `code_refs` | Resolve and inline code patterns for sub-agent |
| `status` | Track progress |
| `verification` | Post-completion check |
| `beads_id` | Cross-reference to beads issue (if available) |

### 4. Load Context Files

Read these files to provide full context to sub-agents:

- `context.md` - Project rationale and architecture vision
- `decisions.md` - Architectural decisions with rationale
- `edge-cases.md` - Edge cases mapped to features
- `testing-strategy.md` - Testing philosophy
- `constraints.md` - Global rules
- `code/` directory - List available code pattern files for reference
- `README.md` - Orchestration guide and validation steps

### 5. Discover Available MCP Tools

Check for optional MCP tools that can assist sub-agents:

- **Playwright**: `browser_navigate`, `browser_snapshot`, `browser_click`, `browser_type`, `browser_take_screenshot`
- **Context7**: `resolve-library-id`, `get-library-docs`
- **Documentation**: Microsoft/Azure docs search
- **Sequential Thinking**: `sequentialthinking` for complex problem decomposition

Document which tools are available to pass to sub-agents in their prompts.

### 6. Check Beads Availability

Check if `.beads/` exists and manifest has `beads_id` fields. If available, update issue status during execution.
See `.claude/skills/beads-cli/SKILL.md` for commands.

### 7. Run Initialization (if needed)

If F000 status is `pending`:

1. Read `init.md` from the plan directory
2. Execute the initialization steps to verify environment
3. Confirm all pre-flight checks pass
4. Update F000 status to `completed` in `manifest.jsonl`

### 8. Resolve Code References

Before executing each feature, resolve its code references:

1. Read the `code_refs` array from the feature's manifest entry
2. For each reference (e.g., `code/typescript.md#basic-types`):
   - Parse the file path and anchor (section heading)
   - Read the code file from the plan directory
   - Extract the relevant section content (from heading to next same-level heading)
   - Store the resolved code snippet for inclusion in sub-agent prompt

Example resolution:
```
code_refs: ["code/typescript.md#basic-types", "code/css.md#layout"]

Resolves to:
- Content from `code/typescript.md` section "## Basic Types" or "### Basic Types"
- Content from `code/css.md` section "## Layout" or "### Layout"
```

### 9. Execute Features Sequentially

Execute features one at a time in dependency order:

1. **Check Dependencies**: Ensure all `depends_on` features are `completed`

2. **CRITICAL - Verify Dependencies Actually Complete**: Before proceeding, RUN the verification command for each dependency to confirm it actually completed. Do NOT trust manifest status alone.

3. **Update Status**: Mark feature as `in_progress` in `manifest.jsonl`
   - **If beads available**: Also run `bd update <beads_id> --status in_progress`

4. **Read Prompt**: Load the corresponding prompt file

5. **Resolve Feature Context**: Gather all context for this feature:
   - **Code patterns**: Resolve each `code_refs` entry (see Step 4.5)
   - **Edge cases**: Look up each `edge_cases` ID in `edge-cases.md` to get full descriptions
   - **Decisions**: Look up each `decisions` ID in `decisions.md` to get rationale

6. **Spawn Sub-Agent**: Use the Task tool with `subagent_type: "general-purpose"` to:

   - Execute the feature implementation using TDD workflow
   - The prompt should include:
     - The full content of the feature prompt file
     - **Resolved code snippets** from `code_refs` (actual code, not just references)
     - **Edge case details**: For each edge case ID, include the case description and handling from `edge-cases.md`
     - **Decision details**: For each decision ID, include the decision and rationale from `decisions.md`
     - Reminder to read `constraints.md` for global rules
     - **Available MCP tools** discovered in Step 3.5
     - **TDD workflow requirements**: Must follow Red-Green-Refactor cycle
     - **Build and test requirements**: Must verify build passes and all tests pass before committing
     - Instruction to commit when complete
     - **Decision IDs to include in commit message** (from manifest `decisions` array)

   Example sub-agent prompt structure:
   ```
   # Feature Implementation: [ID] - [Title]

   ## Prompt
   [Full content of the feature prompt file]

   ## Code Patterns to Follow
   [Resolved code snippets from code_refs]

   ## Edge Cases to Handle
   - EC001: [Description] → [Handling]
   - EC002: [Description] → [Handling]

   ## Relevant Decisions
   - D001: [Decision] — [Rationale]
   - D002: [Decision] — [Rationale]

   ## Available Tools
   [List of MCP tools available for use]

   ## TDD Workflow (MANDATORY)
   You MUST follow Test-Driven Development. For each piece of functionality:

   ### 1. RED - Write Failing Tests First
   - Write test(s) that define the expected behavior
   - Run tests to confirm they FAIL (this validates the test is meaningful)
   - Do NOT write implementation code yet

   ### 2. GREEN - Write Minimal Implementation
   - Write the simplest code that makes the tests pass
   - Run tests to confirm they PASS
   - Do NOT add functionality beyond what tests require

   ### 3. REFACTOR - Improve Code Quality
   - Clean up code while keeping tests green
   - Remove duplication, improve naming, simplify logic
   - Run tests after each refactor to ensure they still pass

   ### TDD Rules
   - NEVER write implementation code before its corresponding test
   - Each test should test ONE specific behavior
   - Tests must be deterministic and independent
   - Include tests for edge cases listed above
   - If you find yourself writing code without a test, STOP and write the test first

   ## Pre-Commit Requirements
   Before committing, you MUST verify:
   1. **All tests written first**: Confirm TDD workflow was followed
   2. **Lint all modified files**: Run linter on all modified files and fix any issues
      - TypeScript/JavaScript: eslint, tsc --noEmit
      - Python: ruff, mypy, black --check
      - Go: golint, go vet, gofmt -d
      - Rust: cargo clippy, cargo fmt --check
      - CSS/SCSS: stylelint
      - Markdown: markdownlint
      - JSON/YAML: prettier --check
      - Use project-specific linter config if available
   3. **Format all modified files**: Run formatter on all modified files
      - TypeScript/JavaScript: prettier
      - Python: black, isort
      - Go: gofmt
      - Rust: cargo fmt
      - CSS/SCSS: prettier
      - Markdown: prettier
      - JSON/YAML: prettier
      - Use project-specific formatter config if available
   4. **Build passes**: Run the project build command and confirm no errors
   5. **All tests pass**: Run the test suite and confirm all tests pass
   6. **Feature verification**: Run the feature-specific verification command

   Do NOT commit if linting fails, formatting is incorrect, build fails, or any tests fail. Fix issues first.

   ## Commit Requirements
   After build and tests pass, commit with these decision IDs: D001, D002
   ```

7. **CRITICAL - Verify Completion Before Marking Complete**: After sub-agent completes:

   **WARNING: Do NOT mark as completed unless ALL verification passes. Do NOT trust sub-agent claims alone.**

   - **Verify TDD workflow followed**: Confirm tests were written before implementation
   - **Verify linting passed**: Confirm all modified files pass linting with no errors
   - **Verify formatting applied**: Confirm all modified files are properly formatted
   - **Verify build passes**: Run the build command yourself and confirm it succeeded
   - **Verify all tests pass**: Run the test suite yourself and confirm all passed
   - **Verify test coverage**: Confirm new functionality has corresponding tests
   - **RUN the feature-specific verification command yourself** - Do NOT skip this step
   - **Verify git commit was made**: Check git log for the expected commit
   - **Verify commit message includes relevant decision IDs** from the manifest `decisions` array

8. **Quality Review Phase**: After feature verification passes, run automated quality review:

   **CRITICAL: Quality review runs after feature verification succeeds. Issues found here trigger bugfix phase.**

   1. **Get changed files**: Get list of files changed in this feature's commit(s)

   2. **Run parallel quality agents** (all 4 agents in parallel):

      ```bash
      # Spawn 4 agents in parallel to review quality from different angles
      Agent 1: Code-Reviewer (code-review:code-review)
      Agent 2: PR-Test-Analyzer (pr-review-toolkit:review-pr)
      Agent 3: Silent-Failure-Hunter (detect suppressed errors, missing error handling)
      Agent 4: Completeness-Checker (detect incomplete implementations)
      ```

      For each agent, provide:
      - List of changed files from the feature
      - Brief description of what the feature does
      - Instruction to check for the specific quality dimension:
        - **Code-Reviewer**: Style violations, potential bugs, CLAUDE.md adherence
        - **PR-Test-Analyzer**: Test coverage gaps, missing edge case tests, critical test failures
        - **Silent-Failure-Hunter**: Inadequate error handling, suppressed exceptions, unhandled promise rejections
        - **Completeness-Checker**: NotImplementedException, empty method bodies, disabled tests, TODO/FIXME/HACK markers

   3. **Collect review results**: Wait for all 4 agents to complete and gather findings

   4. **Evaluate quality gate**:
      - **If NO issues found**: Mark feature as `completed` (proceed to step 9)
      - **If CRITICAL issues found**: Create bugfix subtask and proceed to bugfix phase (see step 8A below)
      - **If MINOR issues found**: Log issues but still mark as `completed` (optional follow-up work)

   **Note**: Quality review is automated verification to catch common issues before marking complete.

8A. **Bugfix Phase** (if critical issues found):

   If critical quality issues are detected:

   1. **Create bugfix issue** (if beads available):
      ```bash
      # Get the feature task's beads_id from manifest
      FEATURE_BEADS_ID=$(jq -r --arg fid "<feature_id>" \
        'select(.id == $fid) | .beads_id' <plan-dir>/manifest.jsonl)

      # Create bugfix as child of the feature task (not epic)
      bd create --title "bugfix: resolve quality issues in <feature_id>" \
                --parent=$FEATURE_BEADS_ID \
                --labels bugfix,quality-review \
                --body "Quality review found critical issues:
      [List of issues from quality agents]

      Files affected: [List of files]"
      ```

   2. **Spawn bugfix sub-agent** with:
      - List of issues from quality review
      - Changed files to fix
      - Instruction to apply minimal fixes addressing only the critical issues
      - TDD requirement for any new tests
      - Instruction to commit when complete

   3. **Verify bugfix completion**: Run verification again for the feature
      - If bugfix verification passes, mark feature as `completed`
      - If bugfix verification fails, ask user whether to retry, skip, or abort
      - If user skips, mark feature as `failed` and continue to next feature

9. **Only if ALL above checks pass**: Update `manifest.jsonl` status to `completed`
   - **If beads available**: Also run `bd close <beads_id> --reason="Quality review passed, verified and committed"`

10. **Handle Failures**: If a feature fails:
    - Mark status as `failed` in `manifest.jsonl`
    - Log the failure reason
    - Ask user whether to retry, skip, or abort
    - Do NOT proceed to next feature until user responds

### 11. Resume Safeguards

When resuming an interrupted plan (branch already exists):

1. **Re-verify ALL "completed" features**: Run the verification command for each feature marked as "completed"
2. **If any verification fails**: Reset that feature's status to `pending`
3. **Log which features were reset**: Inform user which features need to be re-done
4. **Continue from first pending feature**: Do not skip features based solely on manifest status

**CRITICAL: Never trust manifest status on resume. Always verify actual state.**

### 12. Final Validation

After all implementation features complete:

1. **Read `README.md`** for any orchestration-specific validation steps or acceptance criteria
2. Run the E2E validation prompt (typically the last prompt)
3. If Playwright MCP is available:
   - Take screenshots to document the final state
   - Capture console messages for any errors
4. Generate a summary report comparing results against:
   - Goals from `context.md`
   - Acceptance criteria from `README.md`
   - All edge cases from `edge-cases.md` were addressed

### 13. Suggest Documentation Updates

After validation, analyze project documentation and suggest updates based on new features:

1. **Read project documentation**:
   - `CLAUDE.md` in project root (if exists)
   - `README.md` in project root (if exists)
   - Any other relevant documentation files

2. **Analyze implemented features**:
   - Review all completed features from `manifest.jsonl`
   - Identify new functionality, APIs, commands, or components
   - Note architectural changes from `decisions.md`
   - Consider edge cases that users should know about

3. **Generate suggested updates for CLAUDE.md**:
   - New commands or features to document
   - Updated architecture descriptions
   - New dependencies or tools introduced
   - Changed workflows or conventions
   - New rules or constraints to follow

4. **Generate suggested updates for README.md**:
   - New features for users
   - Updated installation or setup steps
   - New usage examples
   - Changed configuration options
   - Updated API documentation

5. **Present suggestions to user**:
   - Show diff-style suggestions for each file
   - Explain why each update is recommended
   - Ask user to approve, modify, or skip each suggestion

6. **Apply approved updates**:
   - Edit documentation files with approved changes
   - Commit documentation updates separately:
     ```
     docs: update documentation for <plan-name> features

     - Updated CLAUDE.md with [summary]
     - Updated README.md with [summary]
     ```

### 14. Sync Beads (if available)

Before creating the PR, sync beads to persist all status changes:

```bash
bd sync
bd stats  # Show final progress summary
```

This ensures all issue closures are committed and pushed.

### 15. Create Pull Request (NEVER Merge to Main)

**CRITICAL: NEVER merge to main. NEVER push to main. Create a PR instead.**

After all features are complete and validated:

1. **Push feature branch**: `git push -u origin plan/<plan-name>`
2. **Create pull request**: Use `gh pr create` to create a PR from the plan branch to main
3. **Include in PR description**:
   - Summary of features implemented
   - Link to the plan directory
   - Any notes for reviewers
4. **Return PR URL to user**: Let user review and merge manually

```bash
# Push feature branch (OK to push to feature branch)
git push -u origin plan/<plan-name>

# Create PR (NEVER merge directly)
gh pr create --title "feat: <plan-name>" --body "..."
```

**WARNING**: Do NOT run `git checkout main`, `git merge`, or `git push origin main`. All code stays on the feature branch until user manually merges the PR.



## Updating manifest.jsonl

To update status in JSONL format:

1. Read all lines from `manifest.jsonl`
2. Parse each line as JSON
3. Find the feature by ID
4. Update the status field
5. Write all lines back to `manifest.jsonl`

Example status update:
```
{"id":"F001",...,"status":"pending",...}
```
becomes:
```
{"id":"F001",...,"status":"completed",...}
```

## Output

After execution completes, provide:

1. Summary of features implemented with their IDs
2. Code patterns used (from `code/` directory)
3. Edge cases addressed (with IDs and descriptions)
4. Decisions applied (with IDs and how they influenced implementation)
5. **TDD compliance**: Confirmation that Red-Green-Refactor workflow was followed for each feature
6. **Code quality**: Confirmation that linting passed and formatting applied for all modified files
7. **Build and test results**: Confirmation that build passed and all tests passed for each feature
8. **Test coverage**: Summary of tests added for new functionality
9. **Quality review results**: Summary of quality review findings per feature (code-reviewer, pr-test-analyzer, silent-failure-hunter, completeness-checker)
10. **Bugfix phase summary** (if triggered): Issues found, bugfixes applied, re-verification results. Note: Bugfix issues are created as **children of feature tasks**, not siblings under the epic
11. Any failures encountered and resolution attempts
12. Links to commits made (verify decision IDs in commit messages)
13. Screenshots from E2E validation (if Playwright available)
14. Validation results compared against `README.md` acceptance criteria
15. **Documentation updates**: Summary of changes made to CLAUDE.md and README.md
16. **Beads summary** (if available): Epic ID, features closed, `bd stats` output
17. **Pull request URL**: Link to the PR created for user to review and merge


## Example Usage

```
/orchestrate-plan dev/active/ui-updates
```

This will:

1. **Create branch** `plan/ui-updates` (or switch to it if resuming)
2. **STATE RECONCILIATION**: Sync manifest and beads status (beads is authoritative)
   - Run `bd sync` to get latest beads state
   - Reconcile all state differences between manifest and beads
   - Log all reconciliation actions
3. **If resuming**: Re-verify all "completed" features, reset any that fail verification
4. Read `dev/active/ui-updates/manifest.jsonl` with all field data
5. Load context from `context.md`, `decisions.md`, `edge-cases.md`, `testing-strategy.md`, `README.md`
6. List available code patterns in `code/` directory
7. Discover available MCP tools
8. Run `init.md` verification (F000)
9. **Execute features sequentially**:
   - For each pending feature in dependency order
   - Verify dependencies actually completed (run verification commands)
   - Spawn sub-agent for the feature
   - **Run quality review** (4 parallel agents: code-reviewer, pr-test-analyzer, silent-failure-hunter, completeness-checker)
   - If critical issues found, trigger bugfix phase and re-verify
   - Verify all checks pass before marking complete
   - Continue to next feature
10. Track progress in `manifest.jsonl`
11. Run final E2E validation against `README.md` criteria
12. **Suggest documentation updates**:
    - Analyze CLAUDE.md and README.md in project root
    - Generate suggestions based on implemented features
    - Present diff-style suggestions for user approval
    - Apply approved updates and commit
13. **Sync beads** (if available): `bd sync` and show `bd stats`
14. **Push branch and create PR** (NEVER merge to main)


## Error Handling

- **Sub-agent timeout**: Retry once, then mark as failed
- **TDD violation**: Sub-agent wrote implementation before tests; must redo with proper TDD workflow
- **Missing test coverage**: Sub-agent must add tests for uncovered functionality before committing
- **Lint failure**: Sub-agent must fix all linting errors before committing
- **Format failure**: Sub-agent must apply formatting to all modified files before committing
- **Build failure**: Sub-agent must fix before committing; if unable, mark as failed
- **Test failure**: Sub-agent must fix before committing; if unable, mark as failed
- **Verification failure**: Do NOT mark as completed, mark as `failed` and ask user how to proceed
- **Quality review agent timeout**: Retry once, then warn user and skip quality review for that agent (log as warning). Applies to all 4 agents: code-reviewer, pr-test-analyzer, silent-failure-hunter, completeness-checker
- **Quality review critical issues**: Create bugfix issue, spawn bugfix sub-agent, re-verify. If bugfix verification fails, ask user how to proceed
- **Quality review agent crash**: Log error, continue without that agent's review (partial quality review). Note in output that review was incomplete. Applies to all 4 agents
- **Bugfix sub-agent timeout**: Retry once, then mark feature as `failed` and ask user how to proceed
- **Bugfix verification failure**: Ask user whether to retry bugfix, skip feature, or abort
- **Dependency verification failure**: Reset dependency to `pending`, re-run it before continuing
- **Git conflict**: Pause and ask user for resolution
- **Missing files**: Abort with clear error message
- **Dependency not met**: Wait for dependency to complete (sequential execution)
- **Missing code_refs**: Warn but continue (code patterns are helpful but not blocking)
- **Decision IDs missing from commit**: Warn user, optionally amend commit
- **MCP tool unavailable**: Continue without that tool, note in output
- **Missing linter/formatter**: Use available tools; warn if project-specific config not found
- **Missing CLAUDE.md or README.md**: Skip documentation suggestions for missing files
- **Documentation update rejected**: Continue without updating; note in output
- **Branch already exists**: Switch to existing branch, re-verify all "completed" features (including quality review)
- **PR creation failure**: Retry once, then ask user for help
- **Beads unavailable**: Continue without beads tracking; rely on manifest.jsonl only
- **Beads sync failure**: Warn user, continue with local state; suggest manual `bd sync` later
- **DevOps task update failure**: Log warning but continue (see EC020 handling below)

## DevOps Task Status Sync

When a `.devops` file exists in the plan directory, update DevOps task status during orchestration to keep it synchronized with feature implementation progress.

### Manifest with DevOps IDs

The manifest.jsonl should include a `devops_id` field for each feature (created by plan-optimize):

```jsonl
{"id":"F001","file":"prompts/01-setup.md","description":"...","status":"pending","devops_id":"12345",...}
{"id":"F002","file":"prompts/02-implementation.md","description":"...","status":"pending","devops_id":"12346",...}
```

### Loading DevOps Configuration

At the start of orchestration:

```bash
# Load DevOps configuration from .devops file
if [ -f "$PLAN_DIR/.devops" ]; then
  source "$PLAN_DIR/.devops"  # Sets: ORG, PROJECT, AZURE_DEVOPS_EXT_PAT (optional)
  DEVOPS_ENABLED=true
else
  DEVOPS_ENABLED=false
fi
```

### Update Task to Active (in_progress)

When updating a feature to `in_progress` status, also update the corresponding DevOps task:

```bash
# For each feature being updated to in_progress
if [ "$DEVOPS_ENABLED" = true ]; then
  DEVOPS_TASK_ID=$(echo "$feature" | jq -r '.devops_id // empty')

  if [ -n "$DEVOPS_TASK_ID" ]; then
    # Update DevOps task to Active state
    az boards work-item update $DEVOPS_TASK_ID \
      --state Active \
      --org $ORG --project $PROJECT 2>&1

    if [ $? -eq 0 ]; then
      echo "DevOps task $DEVOPS_TASK_ID marked as Active"
    else
      # EC020: Authentication failure or permission issue - log and continue
      echo "WARNING: Failed to update DevOps task $DEVOPS_TASK_ID to Active - continuing without sync"
    fi
  fi
fi
```

### Update Task to Closed (completed)

When marking a feature as `completed`, also update the corresponding DevOps task:

```bash
# For each feature being marked completed
if [ "$DEVOPS_ENABLED" = true ]; then
  DEVOPS_TASK_ID=$(echo "$feature" | jq -r '.devops_id // empty')

  if [ -n "$DEVOPS_TASK_ID" ]; then
    # Update DevOps task to Closed state
    az boards work-item update $DEVOPS_TASK_ID \
      --state Closed \
      --org $ORG --project $PROJECT 2>&1

    if [ $? -eq 0 ]; then
      echo "DevOps task $DEVOPS_TASK_ID marked as Closed"
    else
      # EC020: Authentication failure or permission issue - log and continue
      echo "WARNING: Failed to update DevOps task $DEVOPS_TASK_ID to Closed - continuing without sync"
    fi
  fi
fi
```

### Error Handling (EC020)

DevOps task status updates are non-critical and should never block feature orchestration:

- **Missing auth**: If `AZURE_DEVOPS_EXT_PAT` is not set, skip DevOps updates silently
- **Auth failure**: If `az boards` command fails (e.g., invalid credentials or insufficient permissions):
  - Log warning message with task ID
  - Continue orchestration normally
  - Do NOT fail the feature
- **Missing devops_id**: If feature has no `devops_id`, skip that feature's DevOps update silently
- **Network issues**: If Azure DevOps is unreachable:
  - Retry once after a short delay
  - Log warning and continue if retry fails

## Progress Tracking

The orchestrator updates `manifest.jsonl` in real-time. User can check progress anytime by reading the file:

```bash
# View status of all features
cat manifest.jsonl | jq -r '[.id, .status, .description] | @tsv'

# Count by status
cat manifest.jsonl | jq -r '.status' | sort | uniq -c
```

**If beads is available**, use `bd stats`, `bd ready`, `bd blocked` for progress tracking.
See `.claude/skills/beads-cli/SKILL.md` for full command reference.

## Now Execute

1. **Create or switch to plan branch**:
   - Extract plan name from `$ARGUMENTS` (e.g., `ui-updates` from `dev/active/ui-updates`)
   - Create branch `plan/<plan-name>` or switch to it if it exists

2. **STATE RECONCILIATION (CRITICAL - MUST RUN FIRST)**:
   - Run `bd sync` to get latest beads state from remote
   - For each feature in `$ARGUMENTS/manifest.jsonl`:
     - Get manifest status and beads_id
     - Skip if no beads_id
     - Get beads status using `bd show $BEADS_ID --format=json`
     - Reconcile state differences (beads is authoritative):
       - Beads closed + manifest pending → update manifest to completed
       - Manifest completed + beads open → close beads
       - Beads in_progress + manifest pending → reset beads to open
       - Manifest in_progress + beads open → reset manifest to pending
     - Log all reconciliation actions
   - See "State Reconciliation" section above for full pattern

3. **If resuming (branch exists)**: Re-verify all "completed" features
   - For each feature with status "completed", run its verification command
   - If verification fails, reset status to "pending"
   - Log which features were reset

4. Read `$ARGUMENTS/manifest.jsonl` to get the feature list and all field data

5. Read context files:
   - `$ARGUMENTS/context.md` for project context
   - `$ARGUMENTS/constraints.md` for global rules
   - `$ARGUMENTS/decisions.md` for architectural decisions
   - `$ARGUMENTS/edge-cases.md` for edge case definitions
   - `$ARGUMENTS/testing-strategy.md` for testing approach
   - `$ARGUMENTS/README.md` for orchestration guidance

6. List files in `$ARGUMENTS/code/` directory to know available code patterns

7. Discover available MCP tools (Playwright, Context7, Documentation, Sequential Thinking)

8. **Check beads availability**: Look for `.beads/` directory and `beads_id` fields in manifest

9. **Execute features SEQUENTIALLY** (one at a time, in dependency order):

   For each pending feature:

   a. **Verify dependencies actually complete**: Run verification command for each dependency
   b. If any dependency fails verification, reset it to pending and process it first
   c. **Update status to in_progress**: In manifest.jsonl, beads (if available), and DevOps (if available):
      - Update manifest.jsonl
      - If beads available: `bd update <beads_id> --status in_progress`
      - If .devops file exists: Update DevOps task to Active (see DevOps Task Status Sync section above)
   d. Prepare enriched context:
      - Read its prompt file
      - Resolve `code_refs` by reading sections from `code/*.md` files
      - Look up `edge_cases` IDs in `edge-cases.md`
      - Look up `decisions` IDs in `decisions.md`
   e. **Spawn ONE sub-agent** with:
      - Full prompt content
      - Resolved code snippets
      - Edge case details
      - Decision details
      - Available MCP tools
      - **TDD workflow requirements**: Red-Green-Refactor cycle mandatory
      - **Pre-commit requirements**: Lint, format, build, and all tests must pass
      - Commit requirements (include decision IDs)
   f. **Wait for sub-agent to complete**
   g. **VERIFY COMPLETION YOURSELF** (do NOT trust sub-agent claims):
      - Run build command and confirm success
      - Run test suite and confirm all pass
      - Run the feature-specific verification command
      - Check git log for expected commit with decision IDs
   h. **If verification passes**: Proceed to quality review (step i below)
   i. **RUN QUALITY REVIEW** (automated quality gates):
      - Get list of changed files from git diff
      - Spawn 4 quality review agents in PARALLEL:
        - Agent 1 (code-review): Check for code style violations, bugs, CLAUDE.md adherence
        - Agent 2 (pr-test-analyzer): Check for test coverage gaps, edge case tests
        - Agent 3 (silent-failure-hunter): Check for unhandled errors, suppressed exceptions
        - Agent 4 (completeness-checker): Check for NotImplementedException, empty methods, disabled tests, TODO/FIXME/HACK markers
      - Collect results from all 4 agents
      - If NO critical issues: Proceed to step j
      - If CRITICAL issues found: Create bugfix subtask, spawn bugfix sub-agent, re-verify, then proceed to step j
   j. **Only if ALL verification AND quality review passes**: Mark as `completed` in manifest.jsonl and DevOps (if available):
      - Update manifest.jsonl status to `completed`
      - If beads available: `bd close <beads_id> --reason="Quality review passed, verified and committed"`
      - If .devops file exists: Update DevOps task to Closed (see DevOps Task Status Sync section above)
   k. **If ANY check fails**: Mark as `failed`, ask user how to proceed
   l. Continue to next feature

10. Run final validation using `README.md` guidance and E2E prompt

11. **Suggest documentation updates**:
    - Read `CLAUDE.md` and `README.md` from project root (if they exist)
    - Analyze all completed features from manifest
    - Generate suggested updates for each documentation file
    - Present diff-style suggestions to user
    - Ask user to approve, modify, or skip each suggestion
    - Apply approved updates and commit separately

12. **Sync beads** (if available): `bd sync` and show `bd stats` for final summary

12A. **Auto-close eligible epics** (if beads available):
   - Run `bd epic close-eligible` to close epics where all children are closed
   - Log closure results
   - Continue even if closure fails (non-blocking)

12B. **Close DevOps Story when epic closes** (if .devops file exists):

   When epics auto-close and a .devops file exists, also close the corresponding Azure DevOps Story:

   ```bash
   # Close DevOps Story when epic closes
   if [ -d .beads ] && [ -f "$PLAN_DIR/.devops" ]; then
     echo "=== Closing DevOps Story ==="

     # Load DevOps configuration
     source "$PLAN_DIR/.devops"  # Sets: STORY_ID, ORG, PROJECT, optional AZURE_DEVOPS_EXT_PAT

     # Verify STORY_ID is set
     if [ -z "$STORY_ID" ]; then
       echo "WARNING: STORY_ID not set in .devops file - skipping Story close"
     else
       # Update Story to Closed state
       az boards work-item update $STORY_ID \
         --state Closed \
         --org $ORG --project $PROJECT 2>&1

       if [ $? -eq 0 ]; then
         echo "DevOps Story $STORY_ID marked as Closed"
       else
         # EC020: Authentication failure - log warning and continue
         echo "WARNING: Failed to close DevOps Story $STORY_ID (EC020) - continuing without closure"
       fi
     fi

     echo "=== DevOps Story Closure Complete ==="
   fi
   ```

   **Prerequisites**:
   - `.beads/` directory exists (epic auto-close ran)
   - `.devops` file exists in plan directory with:
     - `STORY_ID`: Azure DevOps Story work item ID
     - `ORG`: Azure DevOps organization name
     - `PROJECT`: Azure DevOps project name
     - Optional `AZURE_DEVOPS_EXT_PAT`: Authentication token (uses default if omitted)

   **Error Handling (EC020 and EC021)**:
   - **EC020 - Auth failure**: If `az boards` command fails (invalid credentials or permissions):
     - Log warning message with Story ID
     - Continue orchestration normally (non-blocking)
   - **EC021 - Story already closed**: If Story is already in Closed state:
     - Command succeeds silently (idempotent)
     - No action needed
   - **Missing .devops file**: Skip this step silently
   - **Missing STORY_ID**: Log warning and skip closure

13. **Push branch and create PR (NEVER merge to main)**:
    - `git push -u origin plan/<plan-name>`
    - `gh pr create --title "feat: <plan-name>" --body "..."`
    - Return PR URL to user



**CRITICAL REMINDERS:**
- Execute features ONE AT A TIME (no parallel execution)
- VERIFY completion yourself (do not trust manifest or sub-agent claims)
- NEVER merge to main
- NEVER push to main
- Always create a PR for user review

Begin orchestration now.
